<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="" />
    <link
      rel="stylesheet"
      as="style"
      onload="this.rel='stylesheet'"
      href="https://fonts.googleapis.com/css2?display=swap&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900&amp;family=Plus+Jakarta+Sans%3Awght%40400%3B500%3B700%3B800"
    />
    <title>vivMorph - AI Image Transformation</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
    <style>
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
    </style>
</head>
<body style='font-family: "Plus Jakarta Sans", "Noto Sans", sans-serif;'>
    
    <!-- Main Upload Screen -->
    <div id="upload-screen" class="relative flex size-full min-h-screen flex-col bg-black justify-between group/design-root overflow-x-hidden">

        
        <!-- Upload Content -->
        <div id="upload-content" class="flex-1">
            <!-- Header -->
            <div class="flex items-center bg-black p-4 pb-2 justify-center lg:px-8">
                <h2 class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 text-lg lg:text-2xl font-bold leading-tight tracking-[-0.015em] text-center">vivMorph</h2>

            </div>
            
            <!-- Upload Mode Toggle -->
            <div class="flex justify-center px-4 mb-6">
                <div class="flex h-12 items-center justify-center rounded-lg bg-[#1a1a1a] border border-[#333] p-1">
                    <label class="flex cursor-pointer h-full grow items-center justify-center overflow-hidden rounded-lg px-4 has-[:checked]:bg-gradient-to-r has-[:checked]:from-cyan-500/20 has-[:checked]:to-purple-500/20 has-[:checked]:border has-[:checked]:border-cyan-400/50 has-[:checked]:text-white text-gray-400 text-sm font-medium leading-normal transition-colors">
                        <span class="truncate">Single Image</span>
                        <input type="radio" name="uploadMode" class="invisible w-0" value="single" checked />
                    </label>
                    <label class="flex cursor-pointer h-full grow items-center justify-center overflow-hidden rounded-lg px-4 has-[:checked]:bg-gradient-to-r has-[:checked]:from-cyan-500/20 has-[:checked]:to-purple-500/20 has-[:checked]:border has-[:checked]:border-cyan-400/50 has-[:checked]:text-white text-gray-400 text-sm font-medium leading-normal transition-colors">
                        <span class="truncate">Merge Images</span>
                        <input type="radio" name="uploadMode" class="invisible w-0" value="merge" />
                    </label>
                </div>
            </div>
            
            <!-- Upload Area -->
            <div class="flex-1 flex items-center justify-center p-4 lg:p-8">
                <!-- Single Image Upload -->
                <div id="single-upload" class="text-center max-w-lg mx-auto w-full">
                    <div class="mb-8">
                        <div class="w-24 h-24 lg:w-32 lg:h-32 mx-auto mb-6 bg-gradient-to-br from-cyan-400/20 to-purple-500/20 border border-cyan-400/30 rounded-full flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="text-cyan-400" viewBox="0 0 256 256">
                                <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm0,16V158.75l-26.07-26.06a16,16,0,0,0-22.63,0l-20,20-44-44a16,16,0,0,0-22.62,0L40,149.37V56ZM40,172l52-52,80,80H40Zm176,28H194.63l-36-36,20-20L216,181.38V200ZM144,100a12,12,0,1,1,12,12A12,12,0,0,1,144,100Z"></path>
                            </svg>
                        </div>
                        <h3 class="text-white text-xl lg:text-2xl font-bold mb-2">Transform Your Images with AI</h3>
                        <p class="text-gray-300 text-sm lg:text-base mb-6">Upload any image and use natural language to transform it with cutting-edge AI technology</p>
                    </div>
                    
                    <div class="flex justify-center">
                        <input type="file" id="fileInput" accept="image/*" style="display: none;" />
                        <button id="uploadBtn" class="flex min-w-[200px] cursor-pointer items-center justify-center overflow-hidden rounded-xl h-14 px-8 bg-gradient-to-r from-cyan-500 to-purple-500 text-white text-base font-bold leading-normal tracking-[0.015em] hover:from-cyan-400 hover:to-purple-400 transition-all duration-300 shadow-lg hover:shadow-cyan-500/25">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="mr-2" viewBox="0 0 256 256">
                                <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                            </svg>
                            <span class="truncate">Upload Image</span>
                        </button>
                    </div>
                    
                    <p class="text-gray-400 text-xs lg:text-sm mt-4">Supports JPEG, PNG, WebP up to 10MB</p>
                </div>

                <!-- Dual Image Upload -->
                <div id="merge-upload" class="text-center max-w-2xl mx-auto w-full" style="display: none;">
                    <div class="mb-8">
                        <div class="w-24 h-24 lg:w-32 lg:h-32 mx-auto mb-6 bg-gradient-to-br from-purple-400/20 to-pink-500/20 border border-purple-400/30 rounded-full flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="text-purple-400" viewBox="0 0 256 256">
                                <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM40,56H216V200H40Z"></path>
                                <path d="M88,104a16,16,0,1,1-16,16A16,16,0,0,1,88,104Zm80,0a16,16,0,1,1-16,16A16,16,0,0,1,168,104Z"></path>
                            </svg>
                        </div>
                        <h3 class="text-white text-xl lg:text-2xl font-bold mb-2">Merge Two Images with AI</h3>
                        <p class="text-gray-300 text-sm lg:text-base mb-6">Upload two images: AI will choose the best scene and add the other subject</p>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <!-- Left Image Upload -->
                        <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-6">
                            <div class="mb-4">
                                <div class="w-16 h-16 mx-auto mb-3 bg-gradient-to-br from-cyan-400/20 to-purple-500/20 border border-cyan-400/30 rounded-full flex items-center justify-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="text-cyan-400" viewBox="0 0 256 256">
                                        <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm0,16V158.75l-26.07-26.06a16,16,0,0,0-22.63,0l-20,20-44-44a16,16,0,0,0-22.62,0L40,149.37V56ZM40,172l52-52,80,80H40Zm176,28H194.63l-36-36,20-20L216,181.38V200ZM144,100a12,12,0,1,1,12,12A12,12,0,0,1,144,100Z"></path>
                                    </svg>
                                </div>
                                <h4 class="text-white text-lg font-semibold mb-2">Left Image</h4>
                                <p class="text-gray-400 text-sm">First image to merge</p>
                            </div>
                            <input type="file" id="leftFileInput" accept="image/*" style="display: none;" />
                            <button id="leftUploadBtn" class="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-cyan-500 to-purple-500 text-white rounded-lg font-semibold hover:from-cyan-400 hover:to-purple-400 transition-all duration-300">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256">
                                    <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                                </svg>
                                <span>Upload Left Image</span>
                            </button>
                            <div id="leftImagePreview" class="mt-3 hidden">
                                <img id="leftPreviewImg" class="w-full h-24 object-cover rounded-lg border border-[#333]" alt="Left image preview" />
                            </div>
                        </div>

                        <!-- Right Image Upload -->
                        <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-6">
                            <div class="mb-4">
                                <div class="w-16 h-16 mx-auto mb-3 bg-gradient-to-br from-purple-400/20 to-pink-500/20 border border-purple-400/30 rounded-full flex items-center justify-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="text-purple-400" viewBox="0 0 256 256">
                                        <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40Zm0,16V158.75l-26.07-26.06a16,16,0,0,0-22.63,0l-20,20-44-44a16,16,0,0,0-22.62,0L40,149.37V56ZM40,172l52-52,80,80H40Zm176,28H194.63l-36-36,20-20L216,181.38V200ZM144,100a12,12,0,1,1,12,12A12,12,0,0,1,144,100Z"></path>
                                    </svg>
                                </div>
                                <h4 class="text-white text-lg font-semibold mb-2">Right Image</h4>
                                <p class="text-gray-400 text-sm">Second image to merge</p>
                            </div>
                            <input type="file" id="rightFileInput" accept="image/*" style="display: none;" />
                            <button id="rightUploadBtn" class="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-purple-500 to-pink-500 text-white rounded-lg font-semibold hover:from-purple-400 hover:to-pink-400 transition-all duration-300">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256">
                                    <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                                </svg>
                                <span>Upload Right Image</span>
                            </button>
                            <div id="rightImagePreview" class="mt-3 hidden">
                                <img id="rightPreviewImg" class="w-full h-24 object-cover rounded-lg border border-[#333]" alt="Right image preview" />
                            </div>
                        </div>
                    </div>

                    <!-- Generate Collage Button -->
                    <div class="flex justify-center">
                        <button id="generateCollageBtn" class="flex min-w-[200px] cursor-pointer items-center justify-center overflow-hidden rounded-xl h-14 px-8 bg-gradient-to-r from-purple-500 to-pink-500 text-white text-base font-bold leading-normal tracking-[0.015em] hover:from-purple-400 hover:to-pink-400 transition-all duration-300 shadow-lg hover:shadow-purple-500/25 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="mr-2" viewBox="0 0 256 256">
                                <path d="M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM40,56H216V200H40Z"></path>
                                <path d="M88,104a16,16,0,1,1-16,16A16,16,0,0,1,88,104Zm80,0a16,16,0,1,1-16,16A16,16,0,0,1,168,104Z"></path>
                            </svg>
                            <span class="truncate">Generate Collage</span>
                        </button>
                    </div>
                    
                    <p class="text-gray-400 text-xs lg:text-sm mt-4">AI will choose the best scene and add the other subject</p>
                </div>
            </div>
        </div>
        <!-- Tips Section -->
        <div class="border-t border-[#333] bg-[#111] px-4 py-6 lg:px-8">
            <div class="max-w-4xl mx-auto">
                <h3 class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 text-lg font-bold mb-4 text-center">
                    🚀 Pro Tips for Better AI Transformations
                </h3>
                <div id="merge-tips" class="mb-6 p-4 bg-gradient-to-r from-purple-500/10 to-pink-500/10 border border-purple-500/20 rounded-lg hidden">
                    <h4 class="text-purple-400 font-semibold mb-2 text-center">🔄 Image Merge Mode Tips</h4>
                    <p class="text-gray-300 text-sm text-center mb-3">AI analyzes both images to choose the best scene and adds the other subject naturally into it.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-xs">
                        <div class="bg-[#1a1a1a] border border-[#333] rounded p-3">
                            <span class="text-purple-400 font-semibold">📸</span>
                            <span class="text-gray-300">Choose images with similar lighting and perspective for best results</span>
                        </div>
                        <div class="bg-[#1a1a1a] border border-[#333] rounded p-3">
                            <span class="text-pink-400 font-semibold">🎯</span>
                            <span class="text-gray-300">AI chooses the best scene and adds the other subject naturally</span>
                        </div>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-4 hover:border-cyan-400/50 transition-colors">
                        <div class="flex items-start gap-3">
                            <span class="text-2xl">🎯</span>
                            <div>
                                <h4 class="text-cyan-400 font-semibold mb-1">Be Specific & Clear</h4>
                                <p class="text-gray-300">Use precise colors, detailed descriptions, and clear action verbs. Avoid vague terms.</p>
                            </div>
                        </div>
                    </div>
                    <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-4 hover:border-purple-400/50 transition-colors">
                        <div class="flex items-start gap-3">
                            <span class="text-2xl">🔒</span>
                            <div>
                                <h4 class="text-purple-400 font-semibold mb-1">Preserve What Matters</h4>
                                <p class="text-gray-300">Use "while maintaining the same [facial features/composition/lighting]" to protect important elements.</p>
                            </div>
                        </div>
                    </div>
                    <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-4 hover:border-pink-400/50 transition-colors">
                        <div class="flex items-start gap-3">
                            <span class="text-2xl">👤</span>
                            <div>
                                <h4 class="text-pink-400 font-semibold mb-1">Name Subjects Directly</h4>
                                <p class="text-gray-300">Use "The woman with short hair" instead of "She" or "It" for better recognition.</p>
                            </div>
                        </div>
                    </div>
                    <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-4 hover:border-yellow-400/50 transition-colors">
                        <div class="flex items-start gap-3">
                            <span class="text-2xl">⚡</span>
                            <div>
                                <h4 class="text-yellow-400 font-semibold mb-1">Use the ✨ Optimize Button</h4>
                                <p class="text-gray-300">Let AI improve your prompts using these best practices automatically!</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                 </div>
         
         <!-- Bottom Tab Navigation -->
         <div class="bg-black border-t border-[#333] px-4 py-3">
             <div class="flex justify-center">
                 <div class="flex bg-[#1a1a1a] rounded-full p-1">
                     <button id="uploadTab" class="flex items-center justify-center w-12 h-12 rounded-full transition-all duration-300 bg-gradient-to-r from-cyan-500 to-purple-500 text-white">
                         <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                             <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                         </svg>
                     </button>

                 </div>
             </div>
         </div>
         

    </div>

    <!-- Edit Screen -->
    <div id="edit-screen" class="relative flex size-full min-h-screen flex-col bg-black justify-between group/design-root overflow-x-hidden lg:flex-row" style="display: none;">
        <!-- Header with Back Button -->
        <div class="flex items-center bg-black p-4 pb-2 justify-between lg:px-8 border-b border-[#333] lg:hidden">
            <button id="backBtn-header" class="flex items-center justify-center w-10 h-10 rounded-full transition-all duration-300 text-gray-400 hover:text-white hover:bg-gradient-to-r hover:from-cyan-500/20 hover:to-purple-500/20">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                    <path d="M224,128a8,8,0,0,1-8,8H59.31l58.35,58.34a8,8,0,0,1-11.32,11.32l-72-72a8,8,0,0,1,0-11.32l72-72a8,8,0,0,1,11.32,11.32L59.31,120H216A8,8,0,0,1,224,128Z"></path>
                </svg>
            </button>
            <h2 class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 text-lg font-bold leading-tight tracking-[-0.015em] text-center">vivMorph</h2>
            <div class="w-10 h-10"></div> <!-- Spacer for center alignment -->
        </div>

        <!-- Desktop Header with Back Button -->
        <div class="hidden lg:flex items-center bg-black p-4 pb-2 justify-between lg:px-8 border-b border-[#333] lg:absolute lg:top-0 lg:left-0 lg:right-0 lg:z-10">
            <button id="backBtn-desktop" class="flex items-center justify-center w-10 h-10 rounded-full transition-all duration-300 text-gray-400 hover:text-white hover:bg-gradient-to-r hover:from-cyan-500/20 hover:to-purple-500/20">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                    <path d="M224,128a8,8,0,0,1-8,8H59.31l58.35,58.34a8,8,0,0,1-11.32,11.32l-72-72a8,8,0,0,1,0-11.32l72-72a8,8,0,0,1,11.32,11.32L59.31,120H216A8,8,0,0,1,224,128Z"></path>
                </svg>
            </button>
            <h2 class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 text-lg font-bold leading-tight tracking-[-0.015em] text-center">vivMorph</h2>
            <div class="w-10 h-10"></div> <!-- Spacer for center alignment -->
        </div>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col lg:flex-row lg:pt-16">

            <!-- Image Display Area -->
            <div class="flex-1 flex flex-col lg:w-2/3">

                <!-- Image Container -->
                <div class="flex-1 flex items-center justify-center p-4 lg:p-8">
                    <div class="w-full max-w-4xl rounded-lg flex relative bg-[#1a1a1a] border border-[#333] overflow-hidden min-h-[300px] lg:min-h-[400px]">
                        <div id="imageContainer" class="w-full flex items-center justify-center text-white">
                        </div>
                        <div id="loadingSpinner" class="hidden absolute inset-0 flex items-center justify-center bg-black bg-opacity-75 z-10">
                            <div class="text-center max-w-md w-full mx-4">
                                <div class="mb-6">
                                    <div class="w-16 h-16 mx-auto mb-4 bg-gradient-to-br from-cyan-400/20 to-purple-500/20 border border-cyan-400/30 rounded-full flex items-center justify-center">
                                        <svg class="animate-spin h-8 w-8 text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                    </div>
                                    <p class="text-white text-lg font-semibold mb-2">Transforming your image...</p>
                                    <p class="text-gray-400 text-sm mb-4">Please wait while AI works its magic ✨</p>
                                </div>
                                
                                <!-- Progress Bar -->
                                <div class="w-full bg-gray-700 rounded-full h-3 mb-4 relative">
                                    <div id="progressBar" class="bg-gradient-to-r from-cyan-500 to-purple-500 h-3 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
                                    <div class="absolute inset-0 flex items-center justify-center">
                                        <span id="progressPercent" class="text-white text-xs font-bold">0%</span>
                                    </div>
                                </div>
                                
                                <!-- Progress Text -->
                                <p id="progressText" class="text-cyan-400 text-sm font-medium">Initializing...</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Download Button Under Image -->
                <div id="downloadSection" class="flex justify-center px-4 pb-4 lg:px-8 hidden">
                    <button id="downloadBtn-under-image" class="flex items-center justify-center gap-2 px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-500 text-white rounded-lg font-semibold hover:from-green-400 hover:to-emerald-400 transition-all duration-300 shadow-lg hover:shadow-green-500/25">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                            <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                        </svg>
                        <span>Download Image</span>
                    </button>
                </div>

                <!-- Image Toggle -->
                <div class="flex px-4 py-3 lg:px-8">
                    <div class="flex h-12 flex-1 max-w-md mx-auto lg:mx-0 items-center justify-center rounded-lg bg-[#1a1a1a] border border-[#333] p-1">
                        <label class="flex cursor-pointer h-full grow items-center justify-center overflow-hidden rounded-lg px-4 has-[:checked]:bg-gradient-to-r has-[:checked]:from-cyan-500/20 has-[:checked]:to-purple-500/20 has-[:checked]:border has-[:checked]:border-cyan-400/50 has-[:checked]:text-white text-gray-400 text-sm font-medium leading-normal transition-colors">
                            <span class="truncate">Original</span>
                            <input type="radio" name="imageToggle" class="invisible w-0" value="original" checked />
                        </label>
                        <label class="flex cursor-pointer h-full grow items-center justify-center overflow-hidden rounded-lg px-4 has-[:checked]:bg-gradient-to-r has-[:checked]:from-cyan-500/20 has-[:checked]:to-purple-500/20 has-[:checked]:border has-[:checked]:border-cyan-400/50 has-[:checked]:text-white text-gray-400 text-sm font-medium leading-normal transition-colors">
                            <span class="truncate">Transformed</span>
                            <input type="radio" name="imageToggle" class="invisible w-0" value="transformed" />
                        </label>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="lg:w-1/3 bg-black lg:border-l border-[#333] flex flex-col">
                <!-- Presets -->
                <div class="p-4 lg:p-6 border-b border-[#333]">
                    <h3 class="text-white text-sm font-semibold mb-3">Quick Styles</h3>
                    <div class="grid grid-cols-2 lg:grid-cols-1 gap-2">
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-green-400/50 transition-colors" data-prompt="Transform into Studio Ghibli art style while maintaining the same composition and subjects">
                            <span class="text-green-400 text-sm">🎨</span>
                            <span class="text-white text-xs font-medium">Ghibli</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-red-400/50 transition-colors" data-prompt="Add Donald Trump seamlessly participating in the same activity as the original subjects, maintaining natural lighting and composition while ensuring he blends perfectly with the scene">
                            <span class="text-red-400 text-sm">🇺🇸</span>
                            <span class="text-white text-xs font-medium">Trump</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-cyan-400/50 transition-colors" data-prompt="Replace the background with a tropical beach with white sand, clear blue water, and palm trees while maintaining the same facial features, expressions, body positions, and clothing of all people. Keep accurate camera angle, position, and composition.">
                            <span class="text-cyan-400 text-sm">🏖️</span>
                            <span class="text-white text-xs font-medium">Vacation</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-yellow-400/50 transition-colors" data-prompt="Add beer bottles or wine glasses naturally in the hands of each person while maintaining the same facial features, expressions, hair, and body positions. Keep accurate camera angle, position, and composition exactly as shown.">
                            <span class="text-yellow-400 text-sm">🍺</span>
                            <span class="text-white text-xs font-medium">Drinks</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-orange-400/50 transition-colors" data-prompt="Change clothing to authentic ancient Middle Eastern robes, tunics, and sandals while maintaining the same facial features, expressions, hair color, and body positions of each person. Replace background with ancient Jerusalem stone buildings. Keep accurate camera angle, position, and composition.">
                            <span class="text-orange-400 text-sm">✝️</span>
                            <span class="text-white text-xs font-medium">Biblical</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-pink-400/50 transition-colors" data-prompt="Randomly swap and exchange the faces of all people in the picture with each other, ensuring natural blending and maintaining the same body positions, clothing, and composition exactly as shown.">
                            <span class="text-pink-400 text-sm">🔄</span>
                            <span class="text-white text-xs font-medium">Face Swap</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-purple-400/50 transition-colors" data-prompt="Change clothing to medieval fantasy Westeros-style leather armor, noble house colors, and dark cloaks while maintaining the same facial features, expressions, hair color, and body positions. Replace background with stone castle throne room. Keep accurate camera angle, position, and composition.">
                            <span class="text-purple-400 text-sm">⚔️</span>
                            <span class="text-white text-xs font-medium">GOT</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-amber-400/50 transition-colors" data-prompt="Add well-groomed full beards to each person in the picture while maintaining the same facial features, expressions, eye color, hair color, and body positions. Keep accurate camera angle, position, and composition exactly as shown.">
                            <span class="text-amber-400 text-sm">🧔</span>
                            <span class="text-white text-xs font-medium">Beards</span>
                        </button>
                        <button class="preset-btn flex h-8 items-center justify-start gap-2 rounded-lg bg-[#1a1a1a] border border-[#333] px-3 cursor-pointer hover:bg-[#2a2a2a] hover:border-indigo-400/50 transition-colors" data-prompt="Create a unified scene by determining which image has the better scene/environment and using that as the base. Add the subject from the other image into that base scene, keeping the added subject exactly the same - same person, same face, same facial features, same hair, same clothing, same everything. Do not change any facial features or create a new person. Keep any existing subjects in the base scene exactly as they are. The added subject must be properly scaled to match the size and proportions of the base scene. The goal is to add the new subject to the existing scene without changing anyone, maintaining proper scale and perspective.">
                            <span class="text-indigo-400 text-sm">🔄</span>
                            <span class="text-white text-xs font-medium">Merge</span>
                        </button>
                    </div>
                </div>



                <!-- Prompt Input -->
                <div class="p-4 lg:p-6 flex-1">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-white text-lg font-semibold">Transform Prompt</h3>
                        <button id="optimizeBtn" class="bg-gradient-to-r from-yellow-400 to-orange-500 text-black px-4 py-2 rounded-lg text-sm font-bold hover:from-yellow-300 hover:to-orange-400 transition-all duration-300 shadow-lg hover:shadow-yellow-400/25 border-2 border-yellow-400/50 hover:border-yellow-400">
                            ✨ AI Optimize
                        </button>
                    </div>
                    <div class="space-y-4">
                        <textarea id="promptInput" placeholder="Describe how you want to transform your image..." class="w-full h-32 lg:h-40 resize-none rounded-lg text-white bg-[#1a1a1a] border border-[#333] focus:outline-none focus:ring-2 focus:ring-cyan-400/50 focus:border-cyan-400/50 placeholder:text-gray-400 p-4 text-sm leading-relaxed"></textarea>
                        
                        <div class="flex gap-3">
                            <button id="submitBtn" class="flex-1 cursor-pointer items-center justify-center overflow-hidden rounded-lg h-12 px-4 bg-gradient-to-r from-cyan-500 to-purple-500 text-white text-sm font-bold leading-normal tracking-[0.015em] hover:from-cyan-400 hover:to-purple-400 transition-all duration-300 shadow-lg hover:shadow-cyan-500/25 disabled:opacity-50 disabled:cursor-not-allowed flex">
                                <span class="truncate">Transform Image</span>
                            </button>
                        </div>
                        <div id="iterationIndicator" class="text-xs text-gray-400 text-center py-2 hidden">
                            <span class="bg-purple-500/20 text-purple-400 px-2 py-1 rounded-full border border-purple-500/30">
                                🔄 Transforming from current result
                            </span>
                        </div>
                        
                        <div class="bg-[#1a1a1a] border border-[#333] rounded-lg p-4">
                            <p class="text-gray-300 text-xs leading-relaxed mb-2">
                                <span class="text-cyan-400 font-semibold">💡 Pro Tip:</span> For best results, be specific about what to change while mentioning what should stay the same.
                            </p>
                            <p class="text-gray-400 text-xs leading-relaxed">
                                Try: "Transform into [style] while maintaining the same [subjects/composition]"
                            </p>
                        </div>
                        
                        <!-- Transform Options -->
                        <div class="mt-6 pt-4 border-t border-[#333]">
                            <h4 class="text-white text-sm font-semibold mb-3">Transform Options</h4>
                            <div class="space-y-3">
                                <div class="flex items-center justify-between p-3 bg-[#1a1a1a] border border-[#333] rounded-lg">
                                    <div class="flex items-center gap-3">
                                        <div class="w-8 h-8 bg-gradient-to-br from-cyan-400/20 to-purple-500/20 border border-cyan-400/30 rounded-full flex items-center justify-center">
                                            <span class="text-cyan-400 text-xs">🔄</span>
                                        </div>
                                        <div>
                                            <h5 class="text-white text-sm font-medium">Use Transformed Image</h5>
                                            <p class="text-gray-400 text-xs">ON = Use transformed as seed, OFF = Use original</p>
                                        </div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="editModeToggle" class="sr-only peer">
                                        <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-gradient-to-r peer-checked:from-cyan-500 peer-checked:to-purple-500"></div>
                                    </label>
                                </div>
                                <button id="uploadNewBtn" class="w-full flex items-center justify-center gap-2 p-3 bg-[#1a1a1a] border border-[#333] rounded-lg hover:bg-[#2a2a2a] hover:border-green-400/50 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-green-400" viewBox="0 0 256 256">
                                        <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                                    </svg>
                                    <span class="text-white text-sm font-medium">Upload New Image</span>
                                </button>
                                <button id="downloadBtn" class="w-full flex items-center justify-center gap-2 p-3 bg-[#1a1a1a] border border-[#333] rounded-lg hover:bg-[#2a2a2a] hover:border-cyan-400/50 transition-colors hidden">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-cyan-400" viewBox="0 0 256 256">
                                        <path d="M192,128a8,8,0,0,1-8,8H136v40a8,8,0,0,1-16,0V136H72a8,8,0,0,1-5.66-13.66l48-48a8,8,0,0,1,11.32,0l48,48A8,8,0,0,1,192,128ZM32,208a8,8,0,0,0,8,8H216a8,8,0,0,0,0-16H40A8,8,0,0,0,32,208Z"></path>
                                    </svg>
                                    <span class="text-white text-sm font-medium">Download Image</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Action Navigation -->
        <div id="bottomNav" class="bg-black border-t border-[#333] px-4 py-3 hidden">
            <div class="flex justify-center">
                <div class="flex bg-[#1a1a1a] rounded-full p-1 gap-2">
                    <button id="backBtn-bottom" class="flex items-center justify-center w-12 h-12 rounded-full transition-all duration-300 text-gray-400 hover:text-white hover:bg-gradient-to-r hover:from-cyan-500/20 hover:to-purple-500/20">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                            <path d="M224,128a8,8,0,0,1-8,8H59.31l58.35,58.34a8,8,0,0,1-11.32,11.32l-72-72a8,8,0,0,1,0-11.32l72-72a8,8,0,0,1,11.32,11.32L59.31,120H216A8,8,0,0,1,224,128Z"></path>
                        </svg>
                    </button>
                    <button id="downloadBtn-bottom" class="flex items-center justify-center w-12 h-12 rounded-full transition-all duration-300 text-gray-400 hover:text-white hover:bg-gradient-to-r hover:from-cyan-500/20 hover:to-purple-500/20">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                            <path d="M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145a24,24,0,0,0,34,0l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z"></path>
                        </svg>
                    </button>
                    <button id="shareBtn-bottom" class="flex items-center justify-center w-12 h-12 rounded-full transition-all duration-300 text-gray-400 hover:text-white hover:bg-gradient-to-r hover:from-cyan-500/20 hover:to-purple-500/20">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256">
                            <path d="M229.66,109.66l-48,48a8,8,0,0,1-11.32-11.32L204.69,112H165a88,88,0,0,0-85.23,66,8,8,0,0,1-15.5-4A103.94,103.94,0,0,1,165,96h39.71L170.34,61.66a8,8,0,0,1,11.32-11.32l48,48A8,8,0,0,1,229.66,109.66ZM192,208H40V88a8,8,0,0,0-16,0V208a16,16,0,0,0,16,16H192a8,8,0,0,0,0-16Z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>



    <!-- Error Modal -->
    <div id="errorModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center" style="display: none; z-index: 9999;">
        <div class="bg-[#10231c] border border-[#214a3c] rounded-lg p-6 m-4 max-w-md w-full shadow-2xl">
            <h3 class="text-white text-lg font-bold mb-4">Error</h3>
            <p id="errorMessage" class="text-[#8ecdb7] mb-4"></p>
            <button id="closeError" class="w-full bg-[#019863] text-white px-4 py-2 rounded-lg hover:bg-[#017a50]">OK</button>
        </div>
    </div>

    <script>
        class VivMorph {
            constructor() {
                this.originalImage = null;
                this.originalImageFile = null; // Store the original file
                this.transformedImage = null;
                this.currentView = 'original';
                this.uploadMode = 'single'; // 'single' or 'merge'
                this.leftImage = null;
                this.rightImage = null;
                this.leftImageFile = null;
                this.rightImageFile = null;
                console.log('vivMorph initialized for Netlify deployment');
                this.init();
            }

            init() {
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Upload mode toggle
                document.querySelectorAll('input[name="uploadMode"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.switchUploadMode(e.target.value);
                    });
                });

                // Single image upload
                document.getElementById('uploadBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });

                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                // Dual image upload
                document.getElementById('leftUploadBtn').addEventListener('click', () => {
                    document.getElementById('leftFileInput').click();
                });

                document.getElementById('leftFileInput').addEventListener('change', (e) => {
                    this.handleLeftImageUpload(e);
                });

                document.getElementById('rightUploadBtn').addEventListener('click', () => {
                    document.getElementById('rightFileInput').click();
                });

                document.getElementById('rightFileInput').addEventListener('change', (e) => {
                    this.handleRightImageUpload(e);
                });

                // Generate collage button
                document.getElementById('generateCollageBtn').addEventListener('click', () => {
                    this.generateCollage();
                });

                // Navigation - bottom and header back buttons
                document.getElementById('backBtn-bottom').addEventListener('click', () => {
                    this.showUploadScreen();
                });
                
                document.getElementById('backBtn-header').addEventListener('click', () => {
                    this.showUploadScreen();
                });
                
                document.getElementById('backBtn-desktop').addEventListener('click', () => {
                    this.showUploadScreen();
                });

                // Image toggle
                document.querySelectorAll('input[name="imageToggle"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.toggleImage(e.target.value);
                    });
                });

                // Preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const prompt = e.currentTarget.dataset.prompt;
                        document.getElementById('promptInput').value = prompt;
                    });
                });

                // Transform button
                document.getElementById('submitBtn').addEventListener('click', () => {
                    this.transformImage();
                });

                // Optimize prompt button
                document.getElementById('optimizeBtn').addEventListener('click', () => {
                    this.optimizePrompt();
                });

                // Download buttons - bottom, sidebar, and under image
                document.getElementById('downloadBtn-bottom').addEventListener('click', () => {
                    this.downloadImage();
                });
                
                document.getElementById('downloadBtn').addEventListener('click', () => {
                    this.downloadImage();
                });
                
                document.getElementById('downloadBtn-under-image').addEventListener('click', () => {
                    this.downloadImage();
                });

                // Error modal
                document.getElementById('closeError').addEventListener('click', () => {
                    this.hideErrorModal();
                });

                // Share button - bottom only
                document.getElementById('shareBtn-bottom').addEventListener('click', () => {
                    this.shareImage();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        this.transformImage();
                    }
                });

                // Upload new image button
                document.getElementById('uploadNewBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });

                // Edit mode toggle
                document.getElementById('editModeToggle').addEventListener('change', (e) => {
                    this.updateEditMode(e.target.checked);
                });
            }



            showError(message) {
                document.getElementById('errorMessage').textContent = message;
                document.getElementById('errorModal').style.display = 'flex';
            }

            hideErrorModal() {
                document.getElementById('errorModal').style.display = 'none';
            }

            switchUploadMode(mode) {
                this.uploadMode = mode;
                const singleUpload = document.getElementById('single-upload');
                const mergeUpload = document.getElementById('merge-upload');
                const mergeTips = document.getElementById('merge-tips');
                
                if (mode === 'single') {
                    singleUpload.style.display = 'block';
                    mergeUpload.style.display = 'none';
                    mergeTips.classList.add('hidden');
                } else {
                    singleUpload.style.display = 'none';
                    mergeUpload.style.display = 'block';
                    mergeTips.classList.remove('hidden');
                }
                
                // Reset state when switching modes
                this.resetUploadState();
            }

            resetUploadState() {
                this.originalImage = null;
                this.originalImageFile = null;
                this.transformedImage = null;
                this.leftImage = null;
                this.rightImage = null;
                this.leftImageFile = null;
                this.rightImageFile = null;
                
                // Reset UI
                document.getElementById('generateCollageBtn').disabled = true;
                document.getElementById('leftImagePreview').classList.add('hidden');
                document.getElementById('rightImagePreview').classList.add('hidden');
            }

            async handleLeftImageUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                if (!this.validateImageFile(file)) return;

                try {
                    this.leftImageFile = file;
                    const base64 = await this.fileToBase64(file);
                    this.leftImage = base64;
                    
                    // Show preview
                    const preview = document.getElementById('leftImagePreview');
                    const previewImg = document.getElementById('leftPreviewImg');
                    previewImg.src = `data:image/jpeg;base64,${base64}`;
                    preview.classList.remove('hidden');
                    
                    this.checkCollageReady();
                    
                } catch (error) {
                    this.showError('Error processing left image: ' + error.message);
                }
            }

            async handleRightImageUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                if (!this.validateImageFile(file)) return;

                try {
                    this.rightImageFile = file;
                    const base64 = await this.fileToBase64(file);
                    this.rightImage = base64;
                    
                    // Show preview
                    const preview = document.getElementById('rightImagePreview');
                    const previewImg = document.getElementById('rightPreviewImg');
                    previewImg.src = `data:image/jpeg;base64,${base64}`;
                    preview.classList.remove('hidden');
                    
                    this.checkCollageReady();
                    
                } catch (error) {
                    this.showError('Error processing right image: ' + error.message);
                }
            }

            validateImageFile(file) {
                // Validate file type
                if (!file.type.startsWith('image/')) {
                    this.showError('Please select a valid image file');
                    return false;
                }

                // Check file size (10MB limit)
                if (file.size > 10 * 1024 * 1024) {
                    this.showError('Image file is too large. Please select a file smaller than 10MB');
                    return false;
                }

                return true;
            }

            checkCollageReady() {
                const generateBtn = document.getElementById('generateCollageBtn');
                if (this.leftImage && this.rightImage) {
                    generateBtn.disabled = false;
                } else {
                    generateBtn.disabled = true;
                }
            }

            async generateCollage() {
                if (!this.leftImage || !this.rightImage) {
                    this.showError('Please upload both images first');
                    return;
                }

                const generateBtn = document.getElementById('generateCollageBtn');
                const originalText = generateBtn.innerHTML;
                
                try {
                    generateBtn.disabled = true;
                    generateBtn.innerHTML = '<span class="truncate">Generating...</span>';

                    // Create a simple side-by-side collage
                    const collage = await this.createCollage(this.leftImage, this.rightImage);
                    
                    // Use vision model to analyze the images and generate a merge prompt
                    const mergePrompt = await this.generateMergePrompt(this.leftImage, this.rightImage);
                    
                    // Set the collage as the original image
                    this.originalImage = collage;
                    this.originalImageFile = await this.base64ToFile(collage, 'collage.png');
                    this.transformedImage = null;
                    
                    // Switch to original view
                    this.currentView = 'original';
                    const originalRadio = document.querySelector('input[value="original"]');
                    if (originalRadio) {
                        originalRadio.checked = true;
                    }
                    
                    // Show edit screen
                    this.showEditScreen();
                    this.displayImage();
                    
                    // Set the generated prompt
                    document.getElementById('promptInput').value = mergePrompt;
                    
                    // Update bottom navigation visibility
                    this.updateBottomNavVisibility();
                    
                } catch (error) {
                    console.error('Error generating collage:', error);
                    this.showError('Failed to generate collage: ' + error.message);
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = originalText;
                }
            }

            async createCollage(leftImage, rightImage) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Load both images
                    const leftImg = new Image();
                    const rightImg = new Image();
                    
                    let imagesLoaded = 0;
                    const onImageLoad = () => {
                        imagesLoaded++;
                        if (imagesLoaded === 2) {
                            // Calculate dimensions for side-by-side layout
                            const maxHeight = 512;
                            const leftAspectRatio = leftImg.width / leftImg.height;
                            const rightAspectRatio = rightImg.width / rightImg.height;
                            
                            // Scale images to fit side by side
                            const leftHeight = Math.min(maxHeight, leftImg.height);
                            const leftWidth = leftHeight * leftAspectRatio;
                            const rightHeight = Math.min(maxHeight, rightImg.height);
                            const rightWidth = rightHeight * rightAspectRatio;
                            
                            // Set canvas size
                            canvas.width = leftWidth + rightWidth + 20; // 20px gap
                            canvas.height = Math.max(leftHeight, rightHeight);
                            
                            // Fill background
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Draw images side by side
                            ctx.drawImage(leftImg, 0, (canvas.height - leftHeight) / 2, leftWidth, leftHeight);
                            ctx.drawImage(rightImg, leftWidth + 20, (canvas.height - rightHeight) / 2, rightWidth, rightHeight);
                            
                            // Convert to base64
                            const base64 = canvas.toDataURL('image/png').split(',')[1];
                            resolve(base64);
                        }
                    };
                    
                    leftImg.onload = onImageLoad;
                    rightImg.onload = onImageLoad;
                    
                    leftImg.src = `data:image/jpeg;base64,${leftImage}`;
                    rightImg.src = `data:image/jpeg;base64,${rightImage}`;
                });
            }

            /**
             * Generates an AI-powered merge prompt that focuses on creating a unified scene
             * where both subjects appear together naturally, rather than just a collage.
             * The vision model analyzes both images and suggests how to position both people
             * in the same environment, like they're on vacation or sharing an experience.
             */
            async generateMergePrompt(leftImage, rightImage) {
                try {
                    const response = await fetch('https://api.venice.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ntmhtbP2fr_pOQsmuLPuN_nm6lm2INWKiNcvrdEfEC',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'mistral-32-24b',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are an expert at analyzing images and creating detailed prompts for seamless image merging. Your task is to examine two images and generate a concise, focused prompt (under 800 tokens) that describes how to merge them into a single, unified scene. Analyze both images to determine which has the better scene/environment, then use that as the base scene and add the subject from the other image into it. CRITICAL: The subject being added must remain EXACTLY the same - same person, same face, same facial features, same hair, same clothing, same everything. Do not change any facial features, do not create a new person, do not modify the subject in any way. Keep any existing subjects in the base scene exactly as they are. The added subject must be properly scaled to match the size and proportions of the base scene. The goal is to add the new subject to the existing scene without changing anyone, maintaining proper scale and perspective. Return ONLY the prompt text, no additional explanations or text.'
                                },
                                {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: 'Analyze these two images and create a concise prompt for merging them into a single scene. Determine which image has the better scene/environment and use that as the base. Add the subject from the other image into that base scene, keeping the added subject exactly the same - same person, same face, same facial features, same hair, same clothing, same everything. Do not change any facial features or create a new person. Keep any existing subjects in the base scene exactly as they are. The added subject must be properly scaled to match the size and proportions of the base scene. The goal is to add the new subject to the existing scene without changing anyone, maintaining proper scale and perspective. Return ONLY the prompt text.'
                                        },
                                        {
                                            type: 'image_url',
                                            image_url: {
                                                url: `data:image/jpeg;base64,${leftImage}`
                                            }
                                        },
                                        {
                                            type: 'image_url',
                                            image_url: {
                                                url: `data:image/jpeg;base64,${rightImage}`
                                            }
                                        }
                                    ]
                                }
                            ],
                            max_tokens: 800,
                            temperature: 0.7
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.choices[0].message.content.trim();
                    
                } catch (error) {
                    console.error('Error generating merge prompt:', error);
                    // Enhanced fallback prompt
                    return 'Create a unified scene by determining which image has the better scene/environment and using that as the base. Add the subject from the other image into that base scene, keeping the added subject exactly the same - same person, same face, same facial features, same hair, same clothing, same everything. Do not change any facial features or create a new person. Keep any existing subjects in the base scene exactly as they are. The added subject must be properly scaled to match the size and proportions of the base scene. The goal is to add the new subject to the existing scene without changing anyone, maintaining proper scale and perspective.';
                }
            }

            async base64ToFile(base64, filename) {
                const blob = await this.base64ToBlob(base64, 'image/png');
                return new File([blob], filename, { type: 'image/png' });
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                if (!this.validateImageFile(file)) return;

                try {
                    // Store the original file for API calls
                    this.originalImageFile = file;
                    
                    // Convert to base64 for display
                    const base64 = await this.fileToBase64(file);
                    this.originalImage = base64;
                    this.transformedImage = null;
                    
                    // Reset to original view
                    this.currentView = 'original';
                    const originalRadio = document.querySelector('input[value="original"]');
                    if (originalRadio) {
                        originalRadio.checked = true;
                    }
                    
                    console.log('Image uploaded:', file.name, file.size, 'bytes');
                    
                    // Show edit screen FIRST
                    this.showEditScreen();
                    this.displayImage();
                    
                    // Update bottom navigation visibility (should be hidden since no transformed image)
                    this.updateBottomNavVisibility();
                    

                } catch (error) {
                    this.showError('Error processing image: ' + error.message);
                }
            }

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        // Remove data URL prefix
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            showUploadScreen() {
                document.getElementById('upload-screen').style.display = 'flex';
                document.getElementById('edit-screen').style.display = 'none';
                
                // Clear all file inputs
                document.getElementById('fileInput').value = '';
                document.getElementById('leftFileInput').value = '';
                document.getElementById('rightFileInput').value = '';
                
                // Reset upload state
                this.resetUploadState();
                
                // Hide download button
                const downloadBtn = document.getElementById('downloadBtn');
                if (downloadBtn) downloadBtn.classList.add('hidden');
                
                // Hide download section under image
                const downloadSection = document.getElementById('downloadSection');
                if (downloadSection) downloadSection.classList.add('hidden');
                 
                 // Hide bottom navigation
                 this.updateBottomNavVisibility();
             }
 
             showEditScreen() {
                document.getElementById('upload-screen').style.display = 'none';
                document.getElementById('edit-screen').style.display = 'flex';
            }

            displayImage() {
                const container = document.getElementById('imageContainer');
                const imageToShow = this.currentView === 'original' ? this.originalImage : this.transformedImage;
                const iterationIndicator = document.getElementById('iterationIndicator');
                
                // Clear container first
                container.innerHTML = '';
                
                if (imageToShow) {
                    // Handle both base64 strings and full data URLs
                    const imageUrl = imageToShow.startsWith('data:') ? imageToShow : `data:image/jpeg;base64,${imageToShow}`;
                    
                    // Create img element
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.alt = this.currentView === 'original' ? 'Original Image' : 'Transformed Image';
                    img.className = 'max-w-full max-h-full w-auto h-auto rounded-lg object-contain shadow-lg';
                    img.style.maxHeight = '70vh'; // Prevent images from being too tall
                    img.style.minHeight = '200px'; // Ensure minimum visibility
                    
                    // Add loading state
                    img.addEventListener('load', () => {
                        img.classList.add('opacity-100');
                        img.classList.remove('opacity-0');
                    });
                    
                    img.addEventListener('error', (e) => {
                        console.error('Image failed to load:', e);
                        container.innerHTML = '<p class="text-red-400">Failed to load image</p>';
                    });
                    
                    // Start with fade-in effect
                    img.classList.add('opacity-0', 'transition-opacity', 'duration-300');
                    
                    container.appendChild(img);
                } else if (this.currentView === 'transformed') {
                    container.innerHTML = '<p class="text-gray-400">No transformed image yet</p>';
                } else {
                    container.innerHTML = '<p class="text-gray-400">Upload an image to get started</p>';
                }
                
                // Show iteration indicator if we're viewing transformed image and it exists
                if (iterationIndicator) {
                    if (this.currentView === 'transformed' && this.transformedImage) {
                        iterationIndicator.classList.remove('hidden');
                    } else {
                        iterationIndicator.classList.add('hidden');
                    }
                }
            }

            toggleImage(view) {
                this.currentView = view;
                this.displayImage();
            }

            async transformImage() {
                const prompt = document.getElementById('promptInput').value.trim();
                if (!prompt) {
                    this.showError('Please enter a transformation prompt');
                    return;
                }

                if (!this.originalImageFile) {
                    this.showError('Please upload an image first');
                    return;
                }

                const submitBtn = document.getElementById('submitBtn');
                const loadingSpinner = document.getElementById('loadingSpinner');
                
                try {
                    // Show loading state
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<span class="truncate">Transforming...</span>';
                    if (loadingSpinner) {
                        loadingSpinner.classList.remove('hidden');
                    }
                    
                    // Start progress simulation
                    this.simulateProgress();
                    
                    console.log('Starting transformation...');
                    console.log('Prompt:', prompt);
                    
                    // Determine which image to use as the base based on edit mode toggle
                    const editModeToggle = document.getElementById('editModeToggle');
                    const useTransformed = editModeToggle.checked && this.transformedImage;
                    const imageToUse = useTransformed ? this.transformedImage : this.originalImageFile;
                    
                    // Create form data
                    const formData = new FormData();
                    formData.append('prompt', prompt);
                    
                    if (imageToUse === this.originalImageFile) {
                        // Use original file
                        formData.append('image', this.originalImageFile);
                        console.log('Using original image file:', this.originalImageFile.name, this.originalImageFile.size, 'bytes');
                    } else {
                        // Convert base64 to blob for API
                        const base64 = this.transformedImage;
                        const blob = await this.base64ToBlob(base64, 'image/png');
                        formData.append('image', blob, 'transformed.png');
                        console.log('Using transformed image as base');
                    }
                    
                    console.log('Sending request to Venice AI...');
                    
                    // Convert image to base64 for the serverless function
                    let imageBase64;
                    if (imageToUse === this.originalImageFile) {
                        // Convert original file to base64
                        imageBase64 = await this.fileToBase64(this.originalImageFile);
                    } else {
                        // Use transformed image base64
                        imageBase64 = this.transformedImage;
                    }
                    
                    const response = await fetch('https://api.venice.ai/api/v1/image/edit', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ntmhtbP2fr_pOQsmuLPuN_nm6lm2INWKiNcvrdEfEC',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            image: imageBase64
                        })
                    });
                    
                    console.log('Response status:', response.status);
                    console.log('Response headers:', Object.fromEntries(response.headers));

                    if (!response.ok) {
                        let errorMessage = `HTTP error! status: ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.message || errorData.error || errorMessage;
                        } catch (e) {
                            // If we can't parse JSON, try to get text
                            try {
                                const errorText = await response.text();
                                if (errorText) {
                                    errorMessage = errorText;
                                }
                            } catch (e2) {
                                // Use default error message
                            }
                        }
                        console.error('API Error:', errorMessage);
                        throw new Error(errorMessage);
                    }

                    // Get the transformed image from the response
                    if (response.headers.get('content-type')?.includes('application/json')) {
                        // If it's JSON, parse it
                        const data = await response.json();
                        this.transformedImage = data.image;
                    } else {
                        // If it's binary image data, convert to base64
                        const blob = await response.blob();
                        const base64 = await this.blobToBase64(blob);
                        this.transformedImage = base64;
                    }
                    
                    // Complete progress to 100%
                    this.completeProgress();
                    
                    // Switch to transformed view FIRST (before saving)
                    const transformedRadio = document.querySelector('input[value="transformed"]');
                    if (transformedRadio) {
                        transformedRadio.checked = true;
                    }
                    this.currentView = 'transformed';
                    this.displayImage();
                    
                    // Unhide the main download button
                    const downloadBtn = document.getElementById('downloadBtn');
                    if (downloadBtn) downloadBtn.classList.remove('hidden');

                     // Show bottom navigation now that we have a transformed image
                     this.updateBottomNavVisibility();
                     
 
                     
                 } catch (error) {
                    console.error('Transformation error:', error);
                    this.showError('Failed to transform image: ' + error.message);
                } finally {
                    // Reset loading state
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<span class="truncate">Transform Image</span>';
                    if (loadingSpinner) {
                        loadingSpinner.classList.add('hidden');
                    }
                    
                    // Reset progress
                    this.resetProgress();
                }
            }

            simulateProgress() {
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const progressPercent = document.getElementById('progressPercent');
                
                if (!progressBar || !progressText || !progressPercent) return;
                
                const steps = [
                    { progress: 15, text: 'Analyzing image...' },
                    { progress: 30, text: 'Processing your prompt...' },
                    { progress: 50, text: 'Generating transformation...' },
                    { progress: 70, text: 'Applying AI magic...' },
                    { progress: 85, text: 'Refining details...' },
                    { progress: 95, text: 'Almost done...' }
                ];
                
                let currentStep = 0;
                
                const updateProgress = () => {
                    if (currentStep < steps.length) {
                        const step = steps[currentStep];
                        progressBar.style.width = step.progress + '%';
                        progressPercent.textContent = step.progress + '%';
                        progressText.textContent = step.text;
                        currentStep++;
                        
                        // Random delay between 800ms and 1.5s for realistic feel
                        const delay = Math.random() * 700 + 800;
                        setTimeout(updateProgress, delay);
                    }
                };
                
                // Start progress simulation
                updateProgress();
            }

            resetProgress() {
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const progressPercent = document.getElementById('progressPercent');
                
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                if (progressText) {
                    progressText.textContent = 'Initializing...';
                }
                if (progressPercent) {
                    progressPercent.textContent = '0%';
                }
            }

            completeProgress() {
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const progressPercent = document.getElementById('progressPercent');
                
                if (progressBar) {
                    progressBar.style.width = '100%';
                }
                if (progressText) {
                    progressText.textContent = 'Transformation complete!';
                }
                if (progressPercent) {
                    progressPercent.textContent = '100%';
                }
            }

            updateBottomNavVisibility() {
                const bottomNav = document.getElementById('bottomNav');
                const downloadSection = document.getElementById('downloadSection');
                
                if (bottomNav) {
                    if (this.transformedImage) {
                        bottomNav.classList.remove('hidden');
                    } else {
                        bottomNav.classList.add('hidden');
                    }
                }
                
                if (downloadSection) {
                    if (this.transformedImage) {
                        downloadSection.classList.remove('hidden');
                    } else {
                        downloadSection.classList.add('hidden');
                    }
                }
            }

            blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            base64ToBlob(base64, mimeType) {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: mimeType });
            }

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            updateImageMetadata(base64Image) {
                try {
                    // Create current timestamp in EXIF format
                    const now = new Date();
                    const exifDateTime = now.getFullYear() + ':' + 
                                      String(now.getMonth() + 1).padStart(2, '0') + ':' + 
                                      String(now.getDate()).padStart(2, '0') + ' ' + 
                                      String(now.getHours()).padStart(2, '0') + ':' + 
                                      String(now.getMinutes()).padStart(2, '0') + ':' + 
                                      String(now.getSeconds()).padStart(2, '0');
                    
                    // Convert base64 to data URL
                    const dataURL = 'data:image/jpeg;base64,' + base64Image;
                    
                    // Get existing EXIF data or create new
                    let exifDict = {};
                    try {
                        const exifData = PIEXIF.load(dataURL);
                        exifDict = exifData;
                    } catch (e) {
                        // If no EXIF data exists, create new structure
                        exifDict = {
                            "0th": {},
                            "Exif": {},
                            "GPS": {},
                            "1st": {},
                            "thumbnail": null
                        };
                    }
                    
                    // Update EXIF timestamps
                    exifDict["0th"][PIEXIF.ImageIFD.DateTime] = exifDateTime;
                    exifDict["Exif"][PIEXIF.ExifIFD.DateTimeOriginal] = exifDateTime;
                    exifDict["Exif"][PIEXIF.ExifIFD.DateTimeDigitized] = exifDateTime;
                    
                    // Add software tag
                    exifDict["0th"][PIEXIF.ImageIFD.Software] = "vivMorph AI Image Transformation";
                    
                    // Convert back to base64 with updated EXIF
                    const exifBytes = PIEXIF.dump(exifDict);
                    const newDataURL = PIEXIF.insert(exifBytes, dataURL);
                    
                    // Extract base64 from data URL
                    return newDataURL.split(',')[1];
                } catch (error) {
                    console.warn('Failed to update EXIF metadata:', error);
                    // Return original image if metadata update fails
                    return base64Image;
                }
            }

            async shareImage() {
                const imageToShare = this.currentView === 'original' ? this.originalImage : this.transformedImage;
                
                if (!imageToShare) {
                    this.showError('No image to share');
                    return;
                }

                try {
                    let finalImage = imageToShare;
                    
                    // Update metadata for transformed images
                    if (this.currentView === 'transformed') {
                        finalImage = this.updateImageMetadata(imageToShare);
                    }
                    
                    // Create a download link
                    const link = document.createElement('a');
                    link.href = `data:image/jpeg;base64,${finalImage}`;
                    link.download = `vivMorph-${this.currentView}-${Date.now()}.jpg`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    this.showError('Failed to download image: ' + error.message);
                }
            }

            downloadImage() {
                const imageToDownload = this.currentView === 'original' ? this.originalImage : this.transformedImage;
                
                if (!imageToDownload) {
                    this.showError('No image to download');
                    return;
                }

                try {
                    let finalImage = imageToDownload;
                    
                    // Update metadata for transformed images
                    if (this.currentView === 'transformed') {
                        finalImage = this.updateImageMetadata(imageToDownload);
                    }
                    
                    // Create a download link
                    const link = document.createElement('a');
                    link.href = `data:image/jpeg;base64,${finalImage}`;
                    link.download = `vivMorph-${this.currentView}-${Date.now()}.jpg`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    this.showError('Failed to download image: ' + error.message);
                }
            }

            async optimizePrompt() {
                const promptInput = document.getElementById('promptInput');
                const userPrompt = promptInput.value.trim();
                
                if (!userPrompt) {
                    this.showError('Please enter a prompt first');
                    return;
                }

                const optimizeBtn = document.getElementById('optimizeBtn');
                const originalText = optimizeBtn.textContent;
                
                try {
                    optimizeBtn.textContent = '⏳ Optimizing...';
                    optimizeBtn.disabled = true;

                    const response = await fetch('https://api.venice.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ntmhtbP2fr_pOQsmuLPuN_nm6lm2INWKiNcvrdEfEC',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'llama-3.3-70b',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are an expert AI prompt optimizer for image generation. Your task is to take a user\'s simple prompt and transform it into a detailed, specific prompt that will produce better image generation results. Focus on adding descriptive details about lighting, composition, style, and visual elements while keeping the core intent. Return only the optimized prompt, nothing else.'
                                },
                                {
                                    role: 'user',
                                    content: `Optimize this image generation prompt: "${userPrompt}"`
                                }
                            ],
                            max_tokens: 150,
                            temperature: 0.7
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const optimizedPrompt = data.choices[0].message.content.trim();
                    
                    promptInput.value = optimizedPrompt;
                    
                    // Show success feedback
                    optimizeBtn.textContent = '✅ Optimized';
                    setTimeout(() => {
                        optimizeBtn.textContent = originalText;
                        optimizeBtn.disabled = false;
                    }, 1500);
                    
                } catch (error) {
                    console.error('Error optimizing prompt:', error);
                    this.showError('Failed to optimize prompt: ' + error.message);
                    
                    // Reset button state
                    optimizeBtn.textContent = originalText;
                    optimizeBtn.disabled = false;
                }
            }



            // Edit mode management
            updateEditMode(enabled) {
                const iterationIndicator = document.getElementById('iterationIndicator');
                if (enabled && this.transformedImage) {
                    this.currentView = 'transformed';
                    const transformedRadio = document.querySelector('input[name="imageToggle"][value="transformed"]');
                    if (transformedRadio) {
                        transformedRadio.checked = true;
                    }
                    this.displayImage();
                    if (iterationIndicator) {
                        iterationIndicator.classList.remove('hidden');
                    }
                } else {
                    this.currentView = 'original';
                    const originalRadio = document.querySelector('input[name="imageToggle"][value="original"]');
                    if (originalRadio) {
                        originalRadio.checked = true;
                    }
                    this.displayImage();
                    if (iterationIndicator) {
                        iterationIndicator.classList.add('hidden');
                    }
                }
            }






        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing vivMorph...');
            window.vivMorph = new VivMorph();
        });
    </script>
</body>
</html>